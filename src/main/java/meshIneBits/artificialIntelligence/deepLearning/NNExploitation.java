/*
 * MeshIneBits is a Java software to disintegrate a 3d mesh (model in .stl)
 * into a network of standard parts (called "Bits").
 *
 * Copyright (C) 2016-2021 DANIEL Laurent.
 * Copyright (C) 2016  CASSARD Thibault & GOUJU Nicolas.
 * Copyright (C) 2017-2018  TRAN Quoc Nhat Han.
 * Copyright (C) 2018 VALLON Benjamin.
 * Copyright (C) 2018 LORIMER Campbell.
 * Copyright (C) 2018 D'AUTUME Christian.
 * Copyright (C) 2019 DURINGER Nathan (Tests).
 * Copyright (C) 2020 CLARIS Etienne & RUSSO Andr√©.
 * Copyright (C) 2020-2021 DO Quang Bao.
 * Copyright (C) 2021 VANNIYASINGAM Mithulan.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program. If not, see <https://www.gnu.org/licenses/>.
 */

package meshIneBits.artificialIntelligence.deepLearning;

import java.io.File;
import java.util.Vector;
import meshIneBits.Bit2D;
import meshIneBits.artificialIntelligence.AI_Tool;
import meshIneBits.config.CraftConfig;
import meshIneBits.util.Vector2;
import org.deeplearning4j.nn.multilayer.MultiLayerNetwork;
import org.deeplearning4j.util.ModelSerializer;
import org.jetbrains.annotations.NotNull;
import org.nd4j.linalg.api.ndarray.INDArray;
import org.nd4j.linalg.dataset.api.preprocessor.DataNormalization;
import org.nd4j.linalg.dataset.api.preprocessor.serializer.NormalizerSerializer;
import org.nd4j.linalg.factory.Nd4j;

/**
 * Provides tools to use the neural network once it has been trained.
 */
public class NNExploitation {

  MultiLayerNetwork model;
  DataNormalization normalizer;

  public NNExploitation() {
    restoreNNParams();
  }

  /**
   * Restores the neural network configuration and normalizer.
   */
  private void restoreNNParams() {
    try {
      // 1) restore model
      File locationToSave = new File(AI_Tool.MODEL_PATH);
      this.model = ModelSerializer.restoreMultiLayerNetwork(locationToSave);

      // 2) restore normalizer
      NormalizerSerializer loader = NormalizerSerializer.getDefault();
      this.normalizer = loader.restore(AI_Tool.NORMALIZER_PATH);
      System.out.println("Model and Normalizer restored successfully");

    } catch (Exception e) {
      System.out.println("Neural Network parameters or normalizer could not be restored");
    }
  }

  /**
   * Get an output for new features.
   *
   * @param features the new features.
   * @return the new predicted output corresponding to the given features.
   */
  private double[] getOutputFromNeuralNet(double[][] features) {
    INDArray featuresIND = Nd4j.create(features);
    normalizer.transform(featuresIND);
    return model.output(featuresIND, false)
        .toDoubleVector();
  }

  /**
   * Get a bit predicted placement and orientation depending on the given features.
   *
   * @param sectionPoints    the points of the section in the local coordinate system.
   * @param posLocalSystem   the position of the local coordinate system.
   * @param angleLocalSystem the angle of the local coordinate system.
   * @return the predicted Bit2D.
   */
  public @NotNull Bit2D getBit(@NotNull Vector<Vector2> sectionPoints,
      @NotNull Vector2 posLocalSystem, double angleLocalSystem) {

    double[][] featuresArray = new double[1][sectionPoints.size() * 2];

    int iFeature = 0;
    for (Vector2 point : sectionPoints) {
      featuresArray[0][iFeature] = point.x;
      iFeature++;
      featuresArray[0][iFeature] = point.y;
      iFeature++;
    }

    double[] output = getOutputFromNeuralNet(featuresArray);

    double edgeAbscissa = output[0];
    double localAngle = output[1];

    return getBitFromNeuralNetworkOutput(edgeAbscissa, localAngle, posLocalSystem,
        angleLocalSystem);
  }


  /**
   * Get a bit predicted placement and orientation depending on the given features.
   *
   * @param edgeAbscissa     position of a bit, that comes from the neural network's output
   * @param bitLocalAngle    angle of a bit, that comes from the neural network's output
   * @param posLocalSystem   position of the local coordinate system's origin used to prepare data
   *                         for the neural network
   * @param angleLocalSystem angle of the local coordinate system used to prepare data for the
   *                         neural network
   * @return the bit's center position in global coordinate system
   */

  private @NotNull Bit2D getBitFromNeuralNetworkOutput(double edgeAbscissa, double bitLocalAngle,
      @NotNull Vector2 posLocalSystem, double angleLocalSystem) {
    edgeAbscissa += AI_Tool.paramPosCorrection.getCurrentValue();

    // convert angles in Vector2
    Vector2 bitAngleLocalV2 = Vector2.getEquivalentVector(bitLocalAngle);
    Vector2 angleLocalSystemV2 = Vector2.getEquivalentVector(angleLocalSystem);

    // bit's collinear and orthogonal unit vectors computation
    Vector2 collinear = bitAngleLocalV2.normal();
    Vector2 orthogonal = collinear.rotate(new Vector2(0, -1)); // 90deg anticlockwise rotation

    // bit's center's position in local coordinate system
    Vector2 positionLocal = orthogonal.mul(edgeAbscissa)
        .add(collinear.mul(CraftConfig.lengthFull / 2))
        .sub(orthogonal.mul(CraftConfig.bitWidth / 2));

    // bits center's position in global coordinate system
    Vector2 positionGlobal = positionLocal.rotate(angleLocalSystemV2)
        .add(posLocalSystem);

    Vector2 orientationGlobal = bitAngleLocalV2.rotate(angleLocalSystemV2);

    return new Bit2D(positionGlobal, orientationGlobal);
  }


}
